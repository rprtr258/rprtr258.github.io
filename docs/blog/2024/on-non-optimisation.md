title: Пост про "производительность не нужна"

Тейк "компьютеры сейчас достатотчно быстрые, чтобы положить на производительность и писать на чем угодно и как угодно".

Во первых, достаточно посмотреть на бенчмарки питона, чтобы понять, что он не способен на какую бы то ни было производительность. Почему же питон так медленно считает задачи, для которых остальным языкам требуется в разы меньше времени? Все мы знаем, что это время уходит на интерпретацию: чтение исходных файлов, парсинг, интерпретацию, перестраивание внутренних структур данных и тд, то, что не решает задачу само по себе, а дает возможность выполнять код, который уже решает задачу.

То есть один язык быстрее чем другой по бенчмаркам не потому что один сам по себе какой то "быстрый" язык, а другой "медленный", а потому что один тратит на "обслуживающие" действия больше времени, чем другой. При этом всем, я не говорю, что надо переписывать все на ассемблере и низкоуровневых языках типо C/C++/Rust/Zig/etc. Если понимать, что делает компуктер, чтобы выполнить ваш код, этого уже достаточно, чтобы увидеть, где он делает лишние действия.

Пример с конкатенацией строк:
```go
func Repeat(s string, n int) string {
    result := ""
    for range n {
        // аллокация на каждой конкатенации
        result += s
    }
    return result
}
```
эта функция повторяет строку указанное число раз, например для паддинга. Конкатенация внутри цикла всегда будет вызывать аллокацию и в итоге эта функция будет всегда делать `n` аллокаций. Фикс будет выглядеть примерно так:
```go
func Repeat(s string, n int) string {
    var sb strings.Builder
    sb.Grow(n * len(s))
    for range n {
        sb.WriteString(s)
    }
    return sb.String()
}
```
Мы тут не делаем какой то сверх мега оптимизации, код стал лишь немного сложнее чем исходный и аллокация происходит только один раз в `sb.Grow`. Как вариант, можно воспользоваться [стандартной](https://pkg.go.dev/strings#Repeat) функцией, если таковая есть. Внутри она делает примерно то же, что написали мы, только уже с оптимизациями под кэш.

Можно продолжать примеры с лишними копированиями в куче, переходом по куче указателей, использование связных списков, виртуальных функций и таблиц, а с ними и наследований. Это все при бездумном использовании влечет потери скорости тем больше, чем больше лишней работы из-за них делает процессор. И не надо быть гением оптимизации, чтобы понимать, что делает цпу и учитывать это.

Другая причина этого поста в том, что меня подзаебала тормознутость современного софта. Да, железо стало быстрее. Но софт стал медленнее, причем настолько медленнее, что это, мягко говоря, заметно. Сколько чернил потрачено на прописные истины:
- не делать `O(N^2)` там, где можно делать `O(N)`
- преаллоцировать память и предзагружать данные
- кэшировать, чтобы не загружать/вычислять данные, которые долго загружать/вычислять

Но я буквально сегодня захожу в стим посмотреть сохраненные скрины, а они грузятся секунды 3, из которых картинка грузится ~50мс. Причем еще из-за ебаного юзабилити, я не могу переключать скриншоты к следующему/предыдущему, а надо закрывать скриншот, наводиться на другой скриншот, нажимать на него и ждать пока загрузится он. Что грузит иногда ютуб я в душе не ебу и не хочу знать, но я знаю, что пока он это что-то грузит, страница уже вся отображается, даже показывается видос, но пока не закончится загрузка ЧЕГОТО у меня не отображается плагин для ускорения видео. Можно продолжать и продолжать какую часть своей жизни я трачу на наблюдение лоадинга вместо того, чтобы просто делать свою работу. Вкупе с неудобными интерфейсами периодически подгорает жопа от этого. Типо когда страница вроде бы загрузилась, контент отображается, я навожусь на ссылку, нажимаю, но в последний момент браузер решает дозагрузить именно туда другую ссылку и я жму на хуй пойми что.

Какой из этого вывод? Надо понимать [как работает компьютер](https://www.youtube.com/watch?v=rpy5E6DqoPk) и не писать [заведомо непроизводительный](https://www.youtube.com/watch?v=pgoetgxecw8) код. Это должно покрыть большинство проблем с производительностью, для остальных есть оптимизации.