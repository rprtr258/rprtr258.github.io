<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Abobus | rprtr258</title>
<meta name=keywords content>
<meta name=description content="Кто фанат теории ограничений? Я фанат теории ограничений. Поэтому пост кратко про суть теории ограничений.
Возьмем за данное, что многие процессы сводятся к минимизации некого функционала. Соответственно, сами процессы можно рассматривать как те или иные методы поиска минимума. Также вспомним, что задачи минимизации и максимизации эквивалентны и нет разницы, какую именно рассматривать.
Так вот, для целей обьяснения ограничимся одной областью, которая используется и в самой книге Элияху Голдратта (создателя теории ограничений): производством.">
<meta name=author content>
<link rel=canonical href=https://rprtr258.github.io/posts/2021-06-02-03-39-49/>
<link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://rprtr258.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://rprtr258.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://rprtr258.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://rprtr258.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://rprtr258.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><style>.main{max-width:calc(var(--main-width) + var(--gap) * 14)!important}article.first-entry{justify-content:inherit;min-height:auto}</style>
<script type=text/x-mathjax-config>
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
});
</script>
<script src=/js/mathjax.js></script>
<meta property="og:title" content="Abobus">
<meta property="og:description" content="Кто фанат теории ограничений? Я фанат теории ограничений. Поэтому пост кратко про суть теории ограничений.
Возьмем за данное, что многие процессы сводятся к минимизации некого функционала. Соответственно, сами процессы можно рассматривать как те или иные методы поиска минимума. Также вспомним, что задачи минимизации и максимизации эквивалентны и нет разницы, какую именно рассматривать.
Так вот, для целей обьяснения ограничимся одной областью, которая используется и в самой книге Элияху Голдратта (создателя теории ограничений): производством.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://rprtr258.github.io/posts/2021-06-02-03-39-49/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-06-02T03:39:49+00:00">
<meta property="article:modified_time" content="2021-06-02T03:39:49+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Abobus">
<meta name=twitter:description content="Кто фанат теории ограничений? Я фанат теории ограничений. Поэтому пост кратко про суть теории ограничений.
Возьмем за данное, что многие процессы сводятся к минимизации некого функционала. Соответственно, сами процессы можно рассматривать как те или иные методы поиска минимума. Также вспомним, что задачи минимизации и максимизации эквивалентны и нет разницы, какую именно рассматривать.
Так вот, для целей обьяснения ограничимся одной областью, которая используется и в самой книге Элияху Голдратта (создателя теории ограничений): производством.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rprtr258.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Abobus","item":"https://rprtr258.github.io/posts/2021-06-02-03-39-49/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Abobus","name":"Abobus","description":"Кто фанат теории ограничений? Я фанат теории ограничений. Поэтому пост кратко про суть теории ограничений.\nВозьмем за данное, что многие процессы сводятся к минимизации некого функционала. Соответственно, сами процессы можно рассматривать как те или иные методы поиска минимума. Также вспомним, что задачи минимизации и максимизации эквивалентны и нет разницы, какую именно рассматривать.\nТак вот, для целей обьяснения ограничимся одной областью, которая используется и в самой книге Элияху Голдратта (создателя теории ограничений): производством.","keywords":[],"articleBody":"Кто фанат теории ограничений? Я фанат теории ограничений. Поэтому пост кратко про суть теории ограничений.\nВозьмем за данное, что многие процессы сводятся к минимизации некого функционала. Соответственно, сами процессы можно рассматривать как те или иные методы поиска минимума. Также вспомним, что задачи минимизации и максимизации эквивалентны и нет разницы, какую именно рассматривать.\nТак вот, для целей обьяснения ограничимся одной областью, которая используется и в самой книге Элияху Голдратта (создателя теории ограничений): производством. Применить теорию для других областей уже дело техники и аналогии. Конечной целью производственного процесса является получение прибыли, значит процесс производства - процесс максимизации количества полученной прибыли.\nДалее, лично я выделю два фактора, которые в книге не выделялись, и которые я не видел, чтобы прям использовали, хотя может быть и используют под другими названиями, но все же: последовательность и повторяемость. В процессе производства (глобально, включая транспорт, продажу и тд и тп)\n для получения прибыли нужно продать готовый продукт для получения продукта нужно собрать его из составных частей составные части нужно получить из промежуточных продуктов … первые промежуточные продукты нужно сделать из исходных материалов исходные материалы нужно купить В упрощенном виде процесс производства выглядит так. Хоть тут и есть некоторая доля, допускающая распараллеливание (детали для финального продукта можно делать параллельно), все равно бОльшая часть процесса строго последовательна и эту последовательность необходимо соблюдать. Продолжая эту идею, можно обобщить ее на зависимость задач, представляемых ациклическим графом, тогда порядок будет топологической сортировкой (если не рассматривать параллелизм) или критический путь (если рассматривать неограниченный параллелизм). Первый фактор - последовательность, присутствует. Второй фактор - повторяемость, так же есть: во-первых, редко продукты заказывают поштучно, чаще целыми партиями, а значит промежуточных частей тоже нужно несколько. Во-вторых, после реализации одного заказа, поступят новые заказы, производство не будет останавливаться (ну если только не обанкротится завод), возможно даже, что завод выполняет несколько задач параллельно (ну или номинально параллельно). Тем самым последовательность задач выполняется не один раз, а много, значит есть повторяемость.  Из этих двух факторов можно выделить следующую плюс-минус общую модель. Во-первых, вспомним, как загружается “параллельно” последовательность станков, то есть, есть n станков, m деталей и каждую деталь нужно обработать на каждом станке, причем строго в порядке с первого до последнего. Тогда делаем следующее:\n на первом станке обрабатываем первую деталь, назовем ее d1 d1 обрабатываем на втором станке, d2 (новая деталь) обрабатываем на первом станке d1 - третий станок, d2 - второй, d3 - первый (надеюсь понятна закономерность, если нет, стоит это аккуратно нарисовать на листочке или почитать про https://en.wikipedia.org/wiki/Instruction_pipelining ) x. и так далее Через n шагов все станки будут загружены, через m+n(плюсминусодин) все детали будут готовы. Гораздо лучше, чем за mn шагов обрабатывать каждую деталь по очереди на всех станках. В реальности оказывается, что прогресс не стоит на месте, и на станках можно обрабатывать несколько деталей. Но вот проблема - сколько деталей можно обрабатывать зависит от станка. Пусть на первом станке можно обработать 9 деталей за раз, на втором 10, на третьем 8, а вместо четвертого станка стоит слесарь дядя Вася, который обрабатывает 3 детали за раз. Тогда наш план сверху такой: обработать 9 деталей (d1) на первом станке обработать 9 деталей (d2) на первом станке, 9 (d1) обработать на втором станке обработать 9 деталей (d3) на первом станке, 9 (d2) обработать на втором станке, 8 (d1) обработать на третьем станке, 1 (d1) ждет перед третьим станком обработать 9 деталей (d4) на первом станке, 9 (d3) обработать на втором станке, 1 (d1) и 7 (d2) обработать на третьем станке, 2 (d2) ждет перед третьим станком, 3 (d1) обрабатывает Вася, 5 (d1) ждут Васю обработать 9 деталей (d5) на первом станке, 9 (d4) обработать на втором станке, 2 (d2) и 6 (d3) обработать на третьем станке, 3 (d3) ждет перед третьим станком, 3 (d1) обрабатывает Вася, 3 (d1) и 7 (d2) ждут Васю x. и так далее Оказывается перед третьим станком медленно накапливается очередь, а перед Васей очередь накапливается еще больше. Более того: за раз Вася обрабатывает максимум 3 детали, а значит на все станки после него максимум пойдет 3 детали за раз, а значит за раз вся система (!) выдаст не более 3 товаров за раз (когда до них вообще дойдет дело). По другому это можно представить как трубы воды разной ширины (да, очень похоже на самом деле). На первой картинке ниже есть трубы с разной шириной: 9, 10, 8 и 3, как производительности наших станков. Трубы находятся в строго таком порядке и, если налить в них воду, то она будет течь, как показано красным цветом на второй картинке ниже: сначала будет течь 9 единиц воды, через вторую трубу тоже 9, из этих 9 единиц воды через третью трубу будет успевать протекать 8 единиц воды за единицу времени, а из этих 8 через четвертую трубу в итоге будет выливаться только 3 единицы воды за раз. Опять имеем последовательностьпотоком Получаем, что производительность системы (при допущениях, указанных выше) обусловлена исключительно самым медленным звеном в последовательности. Время терминологии: в теории ограничений такое звено называется узким звеном или просто узким местом. Другими словами, узкое звено »ограничивает«Это краткое описание теории ограничений, без деталей про получающиеся метрики оценки производства и способы управления производством в свете полученных знаний. Что хочется привести в пример, это третью картинку в приложении к посту (да, картинки две, но выше вы поверили, что первая картинка это на самом деле две картинки). Не совсем, конечно, про то, что описывалось до этого, но что-то близкое.\n","wordCount":"928","inLanguage":"en","datePublished":"2021-06-02T03:39:49Z","dateModified":"2021-06-02T03:39:49Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://rprtr258.github.io/posts/2021-06-02-03-39-49/"},"publisher":{"@type":"Organization","name":"rprtr258","logo":{"@type":"ImageObject","url":"https://rprtr258.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://rprtr258.github.io/ accesskey=h title="rprtr258 (Alt + H)">rprtr258</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://rprtr258.github.io/watch_list/ title="Watch list">
<span>Watch list</span>
</a>
</li>
<li>
<a href=https://rprtr258.github.io/cv/ title=CV>
<span>CV</span>
</a>
</li>
<li>
<a href=https://rprtr258.github.io/menhera/ title="Menhera chan">
<span>Menhera chan</span>
</a>
</li>
<li>
<a href=https://rprtr258.github.io/mmheroes/ title=MMHeroes>
<span>MMHeroes</span>
</a>
</li>
<li>
<a href=https://rprtr258.github.io/utils/ title="Utils (18+)">
<span>Utils (18+)</span>
</a>
</li>
<li>
<a href=https://rprtr258.github.io/memes/ title=Memes>
<span>Memes</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://rprtr258.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://rprtr258.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Abobus
</h1>
<div class=post-meta><span title="2021-06-02 03:39:49 +0000 UTC">June 2, 2021</span>
</div>
</header>
<div class=post-content><p>Кто фанат теории ограничений? Я фанат теории ограничений. Поэтому пост кратко про суть теории ограничений.</p>
<p>Возьмем за данное, что многие процессы сводятся к минимизации некого функционала. Соответственно, сами процессы можно рассматривать как те или иные методы поиска минимума. Также вспомним, что задачи минимизации и максимизации эквивалентны и нет разницы, какую именно рассматривать.</p>
<p>Так вот, для целей обьяснения ограничимся одной областью, которая используется и в самой книге Элияху Голдратта (создателя теории ограничений): производством. Применить теорию для других областей уже дело техники и аналогии. Конечной целью производственного процесса является получение прибыли, значит процесс производства - процесс максимизации количества полученной прибыли.</p>
<p>Далее, лично я выделю два фактора, которые в книге не выделялись, и которые я не видел, чтобы прям использовали, хотя может быть и используют под другими названиями, но все же: последовательность и повторяемость. В процессе производства (глобально, включая транспорт, продажу и тд и тп)</p>
<ul>
<li>для получения прибыли нужно продать готовый продукт</li>
<li>для получения продукта нужно собрать его из составных частей</li>
<li>составные части нужно получить из промежуточных продуктов</li>
<li>&mldr;</li>
<li>первые промежуточные продукты нужно сделать из исходных материалов</li>
<li>исходные материалы нужно купить
В упрощенном виде процесс производства выглядит так. Хоть тут и есть некоторая доля, допускающая распараллеливание (детали для финального продукта можно делать параллельно), все равно бОльшая часть процесса строго последовательна и эту последовательность необходимо соблюдать. Продолжая эту идею, можно обобщить ее на зависимость задач, представляемых ациклическим графом, тогда порядок будет топологической сортировкой (если не рассматривать параллелизм) или критический путь (если рассматривать неограниченный параллелизм). Первый фактор - последовательность, присутствует. Второй фактор - повторяемость, так же есть: во-первых, редко продукты заказывают поштучно, чаще целыми партиями, а значит промежуточных частей тоже нужно несколько. Во-вторых, после реализации одного заказа, поступят новые заказы, производство не будет останавливаться (ну если только не обанкротится завод), возможно даже, что завод выполняет несколько задач параллельно (ну или номинально параллельно). Тем самым последовательность задач выполняется не один раз, а много, значит есть повторяемость.</li>
</ul>
<p>Из этих двух факторов можно выделить следующую плюс-минус общую модель. Во-первых, вспомним, как загружается &ldquo;параллельно&rdquo; последовательность станков, то есть, есть n станков, m деталей и каждую деталь нужно обработать на каждом станке, причем строго в порядке с первого до последнего. Тогда делаем следующее:</p>
<ol>
<li>на первом станке обрабатываем первую деталь, назовем ее d1</li>
<li>d1 обрабатываем на втором станке, d2 (новая деталь) обрабатываем на первом станке</li>
<li>d1 - третий станок, d2 - второй, d3 - первый (надеюсь понятна закономерность, если нет, стоит это аккуратно нарисовать на листочке или почитать про <a href=https://en.wikipedia.org/wiki/Instruction_pipelining>https://en.wikipedia.org/wiki/Instruction_pipelining</a> )
x. и так далее
Через n шагов все станки будут загружены, через m+n(плюсминусодин) все детали будут готовы. Гораздо лучше, чем за mn шагов обрабатывать каждую деталь по очереди на всех станках. В реальности оказывается, что прогресс не стоит на месте, и на станках можно обрабатывать несколько деталей. Но вот проблема - сколько деталей можно обрабатывать зависит от станка. Пусть на первом станке можно обработать 9 деталей за раз, на втором 10, на третьем 8, а вместо четвертого станка стоит слесарь дядя Вася, который обрабатывает 3 детали за раз. Тогда наш план сверху такой:</li>
<li>обработать 9 деталей (d1) на первом станке</li>
<li>обработать 9 деталей (d2) на первом станке, 9 (d1) обработать на втором станке</li>
<li>обработать 9 деталей (d3) на первом станке, 9 (d2) обработать на втором станке, 8 (d1) обработать на третьем станке, 1 (d1) ждет перед третьим станком</li>
<li>обработать 9 деталей (d4) на первом станке, 9 (d3) обработать на втором станке, 1 (d1) и 7 (d2) обработать на третьем станке, 2 (d2) ждет перед третьим станком, 3 (d1) обрабатывает Вася, 5 (d1) ждут Васю</li>
<li>обработать 9 деталей (d5) на первом станке, 9 (d4) обработать на втором станке, 2 (d2) и 6 (d3) обработать на третьем станке, 3 (d3) ждет перед третьим станком, 3 (d1) обрабатывает Вася, 3 (d1) и 7 (d2) ждут Васю
x. и так далее
Оказывается перед третьим станком медленно накапливается очередь, а перед Васей очередь накапливается еще больше. Более того: за раз Вася обрабатывает максимум 3 детали, а значит на все станки после него максимум пойдет 3 детали за раз, а значит за раз вся система (!) выдаст не более 3 товаров за раз (когда до них вообще дойдет дело).
По другому это можно представить как трубы воды разной ширины (да, очень похоже на самом деле). На первой картинке ниже есть трубы с разной шириной: 9, 10, 8 и 3, как производительности наших станков. Трубы находятся в строго таком порядке и, если налить в них воду, то она будет течь, как показано красным цветом на второй картинке ниже: сначала будет течь 9 единиц воды, через вторую трубу тоже 9, из этих 9 единиц воды через третью трубу будет успевать протекать 8 единиц воды за единицу времени, а из этих 8 через четвертую трубу в итоге будет выливаться только 3 единицы воды за раз. Опять имеем >последовательность&lt; труб, через которые >потоком&lt; течет вода и производительность всей системы ограничена последним узким узлом.</li>
</ol>
<p>Получаем, что производительность системы (при допущениях, указанных выше) обусловлена исключительно самым медленным звеном в последовательности. Время терминологии: в теории ограничений такое звено называется узким звеном или просто узким местом. Другими словами, узкое звено »>ограничивает«&lt; систему. В примере выше, можно не теряя абсолютно ничего в производительности сбора итогового продукта, на всех станках до Васи делать не по 9, 9 и 8 продуктов за раз, а по 3, 3 и 3: больше просто не успеет пройти дальше!</p>
<p>Это краткое описание теории ограничений, без деталей про получающиеся метрики оценки производства и способы управления производством в свете полученных знаний. Что хочется привести в пример, это третью картинку в приложении к посту (да, картинки две, но выше вы поверили, что первая картинка это на самом деле две картинки). Не совсем, конечно, про то, что описывалось до этого, но что-то близкое.</p>
<p><img loading=lazy src=/img/vk/a590Mz9SxsA.jpg alt>
<img loading=lazy src=/img/vk/Bq0a6pUKwFs.jpg alt>
</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
</ul>
<nav class=paginav>
<a class=prev href=https://rprtr258.github.io/posts/2021-06-02-04-09-51/>
<span class=title>« Prev</span>
<br>
<span>Abobus</span>
</a>
<a class=next href=https://rprtr258.github.io/posts/2021-06/>
<span class=title>Next »</span>
<br>
<span>Abobus</span>
</a>
</nav>
</footer>
</article>
</main>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>